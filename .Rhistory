#########################################
# Loading necessary packages and reason #
#########################################
# Package required to call 'ggplot' function
library(ggplot2)
# Package required to call 'ggarrange' function
library(ggpubr)
# Package required to call 'scatterplot3d' function
library(scatterplot3d)
# Package required to call 'melt' function
library(reshape2)
# Package required to call 'mvn' function
#library(MVN)
# Package required to call 'boxM' function
library(biotools)
# Package required to call 'partimat' function
library(klaR)
# Package required to call 'summarise' function
library(dplyr)
# Package required to call 'createDataPartition' function
library(caret)
# Package required to call 'freq' and 'descr' functions (descriptive statistics)
library(summarytools)
# Package required to call 'ggplot' function (graphical tools)
library(ggplot2)
# Package required to call 'ggarrange' function (graphical tools)
library(ggpubr)
# Package required to call 'read.spss' function (loading '.spss' data format)
library(foreign)
# Package required to call 'read_xlsx' function (loading '.xlsx' data format)
library(readxl)
# Package required to load the data set 'RBGlass1'
library(archdata)
# Package required to call 'cortest.bartlett' function
library(psych)
# Package required to call 'fviz_pca_var, fviz_pca_ind and fviz_pca' functions
library(factoextra)
# Package required to call 'scatterplot3d' function
library(scatterplot3d)
# Package required to call 'hetcor' function
library(polycor)
# Package required to call 'ggcorrplot' function
library(ggcorrplot)
# Package required to call 'corrplot' function
library(corrplot)
# Package required to call 'rplot' function
library(corrr)
# Package required to call 'mvn' function
library(MVN)
# Package required to plot ROC curve
library(pROC)
library(caret)
# Package required to call 'mutate' function
library(tidyverse)
# Package required to call 'clusGap' function
library(cluster)
# Package required to call 'get_dist', 'fviz_cluster' and 'fviz_dist' functions
library(factoextra)
# Package required to call 'ggdendrogram' function
library(ggdendro)
# Package required to call 'grid.arrange' function
library(gridExtra)
library(mclust)
library(moments)
# Loading the .csv file
# The output of this function is already a data.frame object
data<-read.csv("train.csv", header = TRUE,sep =",", fileEncoding = "UTF-8")
# This line loads the variable names from this data.frame
# So that we can access by their name with no refer to the data.frame identifier
attach(data)
# We will only select 17 variables for our study
data <- data[, c(
"MSSubClass",
"MSZoning",
"LotFrontage",
"LotArea",
"OverallQual",
"OverallCond",
"YearBuilt",
"ExterQual",
"ExterCond",
"GarageQual",
"GrLivArea",
"X1stFlrSF",
"X2ndFlrSF",
"YrSold",
"SaleType",
"SaleCondition",
"SalePrice"
)]
# Retrieving the name of the selected variables
colnames(data)
# Displaying a few records
head(data)
# Number of NA's values per column
na_counts <- colMeans(is.na(data))
print(na_counts)
# Classical numeric descriptive analysis
describe(MSSubClass)
freq(MSSubClass)
# Histogram and density plots
p1<-ggplot(data,aes(x=MSSubClass))+geom_histogram()+
labs(title = "Histogram of MSSubClass",x="MSSubClass",y="Values")
p1
# Missing Values
na_counts <- sum(is.na(data$MSSubClass))
print(na_counts)
# Boxplot to visualize outliers
p1 <- ggplot(data, aes(x = MSSubClass)) +
geom_boxplot(outlier.colour = "red", outlier.shape = 1, outlier.size = 2) +
coord_flip() +
labs(title = "Boxplot of MSSubClass", x = "Values", y = "")
# Count outliers
outliers <- boxplot.stats(data$MSSubClass)$out
# Display the count of outliers
cat("Number of outliers:", length(outliers), "\n")
# Identify rows with outliers
outlier_rows <- which(data$MSSubClass %in% outliers)
# Print the indices of rows with outliers
cat("Indices of rows with outliers:", outlier_rows, "\n")
p1
# Remove rows with outliers
data <- data[-outlier_rows, ]
# Print a message after removing outliers
cat("Outliers removed. New number of rows:", nrow(data), "\n")
# Basic descriptive statistics
freq(MSZoning)
# Pie chart and bar graph
p1<-ggplot(data, aes(x=factor(1), fill = MSZoning))+geom_bar()+
coord_polar("y")+labs(x="MSZoning",y="%")
p2<-ggplot(data, aes(x=factor(1), fill = MSZoning))+geom_bar()+
labs(x="MSZoning",y="%")
# This function controls the graphical output device
ggarrange(p1,p2,nrow = 1,ncol=2, common.legend = TRUE)
# Classical numeric descriptive analysis
describe(LotFrontage)
# Histogram and density plots
p1<-ggplot(data,aes(x=LotFrontage))+geom_density()+
labs(title = "Density of LotFrontage",x="LotFrontage",y="Values")
p2<-ggplot(data,aes(x=LotFrontage))+geom_histogram()+
labs(title = "Histogram of LotFrontage",x="LotFrontage",y="Values")
# This function controls the graphical output device
ggarrange(p1,p2, nrow=1, common.legend = FALSE)
# Missing Values
na_counts <- sum(is.na(data$LotFrontage))
print(na_counts)
print(na_counts/nrow(data))
# Create a subset for non-missing values
non_missing_values <- data$LotFrontage[!is.na(data$LotFrontage)]
# Perform a t-test for continuous variables
result <- t.test(non_missing_values, data$LotFrontage, alternative = "two.sided")
print(paste("Variable: LotFrontage"))
print(result)
# Calculate the mean of non-missing values
mean_lot_frontage <- mean(data$LotFrontage, na.rm = TRUE)
# Replace missing values with the mean
data$LotFrontage[is.na(data$LotFrontage)] <- mean_lot_frontage
na_counts <- sum(is.na(data$LotFrontage))
print(na_counts)
print(na_counts/nrow(data))
describe(data$LotFrontage)
# Histogram and density plots
p1<-ggplot(data,aes(x=data$LotFrontage))+geom_density()+
labs(title = "Density of LotFrontage",x="LotFrontage",y="Values")
p2<-ggplot(data,aes(x=data$LotFrontage))+geom_histogram()+
labs(title = "Histogram of LotFrontage",x="LotFrontage",y="Values")
# This function controls the graphical output device
ggarrange(p1,p2, nrow=1, common.legend = FALSE)
# Boxplot to visualize outliers
p1 <- ggplot(data, aes(x = LotFrontage)) +
geom_boxplot(outlier.colour = "red", outlier.shape = 1, outlier.size = 2) +
coord_flip() +
labs(title = "Boxplot of LotFrontage", x = "Values", y = "")
ggarrange(p1, nrow=1, common.legend = FALSE)
# Count outliers
outliers <- boxplot.stats(data$LotFrontage)$out
# Display the count of outliers
cat("Number of outliers:", length(outliers), "\n")
# Identify rows with outliers
outlier_rows <- which(data$LotFrontage %in% outliers)
# Print the indices of rows with outliers
cat("Indices of rows with outliers:", outlier_rows, "\n")
# Remove rows with outliers
data <- data[-outlier_rows, ]
# Print a message after removing outliers
cat("Outliers removed. New number of rows:", nrow(data), "\n")
# Histogram representation of the column LotFrontage
par(mfcol = c(1, 1))
# Define the column name
j0 <- "LotFrontage"
# Set the sequence for the x-axis
x0 <- seq(min(data[, j0], na.rm = TRUE), max(data[, j0], na.rm = TRUE), length.out = 50)
# Create a histogram for the entire column
hist(data[, j0], prob = TRUE, col = grey(0.8), main = paste("Histogram of", j0), xlab = j0)
# Overlay normal distribution curve
lines(x0, dnorm(x0, mean(data[, j0], na.rm = TRUE), sd(data[, j0], na.rm = TRUE)), col = "blue", lwd = 2)
# Representation of normal quantiles for the column LotFrontage
par(mfrow = c(1, 1))
# Define the column name
j0 <- "LotFrontage"
# Set the sequence for the x-axis
x0 <- seq(min(data[, j0], na.rm = TRUE), max(data[, j0], na.rm = TRUE), length.out = 50)
# Create a quantile-quantile plot
qqnorm(data[, j0], main = paste("Q-Q Plot of", j0), pch = 19, col = 2)
qqline(data[, j0])
data_tidy <- melt(data, value.name = "value")
result <- aggregate(value ~ variable, data = data_tidy,
FUN = function(x) shapiro.test(x)$p.value)
# Print the row corresponding to LotFrontage
print(subset(result, variable == "LotFrontage"))
# Classical numeric descriptive analysis
describe(LotArea)
# Histogram and density plots
p1<-ggplot(data,aes(x=LotArea))+geom_density()+
labs(title = "Density of LotArea",x="LotArea",y="Values")
p2<-ggplot(data,aes(x=LotArea))+geom_histogram()+
labs(title = "Histogram of LotArea",x="LotArea",y="Values")
# This function controls the graphical output device
ggarrange(p1,p2, nrow=1, common.legend = FALSE)
# Missing Values
na_counts <- sum(is.na(data$LotArea))
print(na_counts)
print(na_counts/nrow(data))
# Boxplot to visualize outliers
p1 <- ggplot(data, aes(x = LotArea)) +
geom_boxplot(outlier.colour = "red", outlier.shape = 1, outlier.size = 2) +
coord_flip() +
labs(title = "Boxplot of LotArea", x = "Values", y = "")
ggarrange(p1, nrow=1, common.legend = FALSE)
# Count outliers
outliers <- boxplot.stats(data$LotArea)$out
# Display the count of outliers
cat("Number of outliers:", length(outliers), "\n")
# Identify rows with outliers
outlier_rows <- which(data$LotArea %in% outliers)
# Print the indices of rows with outliers
cat("Indices of rows with outliers:", outlier_rows, "\n")
# Remove rows with outliers
data <- data[-outlier_rows, ]
# Print a message after removing outliers
cat("Outliers removed. New number of rows:", nrow(data), "\n")
# Histogram representation of the column LotArea
par(mfcol = c(1, 1))
# Define the column name
j0 <- "LotArea"
# Set the sequence for the x-axis
x0 <- seq(min(data[, j0], na.rm = TRUE), max(data[, j0], na.rm = TRUE), length.out = 50)
# Create a histogram for the entire column
hist(data[, j0], prob = TRUE, col = grey(0.8), main = paste("Histogram of", j0), xlab = j0)
# Overlay normal distribution curve
lines(x0, dnorm(x0, mean(data[, j0], na.rm = TRUE), sd(data[, j0], na.rm = TRUE)), col = "blue", lwd = 2)
# Representation of normal quantiles for the column LotArea
par(mfrow = c(1, 1))
# Define the column name
j0 <- "LotArea"
# Set the sequence for the x-axis
x0 <- seq(min(data[, j0], na.rm = TRUE), max(data[, j0], na.rm = TRUE), length.out = 50)
# Create a quantile-quantile plot
qqnorm(data[, j0], main = paste("Q-Q Plot of", j0), pch = 19, col = 2)
qqline(data[, j0])
data_tidy <- melt(data, value.name = "value")
# Use the aggregate function with the correct FUN argument
result <- aggregate(value ~ variable, data = data_tidy,
FUN = function(x) shapiro.test(x)$p.value)
# Print the row corresponding to LotArea
print(subset(result, variable == "LotArea"))
# Classical numeric descriptive analysis
describe(OverallQual)
# Histogram and density plots
p1<-ggplot(data,aes(x=OverallQual))+geom_density()+
labs(title = "Density of OverallQual",x="OverallQual",y="Values")
p2<-ggplot(data,aes(x=OverallQual))+geom_histogram()+
labs(title = "Histogram of OverallQual",x="OverallQual",y="Values")
# This function controls the graphical output device
ggarrange(p1,p2, nrow=1, common.legend = FALSE)
# Missing Values
na_counts <- sum(is.na(data$OverallQual))
print(na_counts)
# Boxplot to visualize outliers
p1 <- ggplot(data, aes(x = OverallQual)) +
geom_boxplot(outlier.colour = "red", outlier.shape = 1, outlier.size = 2) +
coord_flip() +
labs(title = "Boxplot of OverallQual", x = "Values", y = "")
ggarrange(p1, nrow=1, common.legend = FALSE)
# Count outliers
outliers <- boxplot.stats(data$OverallQual)$out
# Display the count of outliers
cat("Number of outliers:", length(outliers), "\n")
# Identify rows with outliers
outlier_rows <- which(data$OverallQual %in% outliers)
# Print the indices of rows with outliers
cat("Indices of rows with outliers:", outlier_rows, "\n")
# Remove rows with outliers
data <- data[-outlier_rows, ]
# Print a message after removing outliers
cat("Outliers removed. New number of rows:", nrow(data), "\n")
# Classical numeric descriptive analysis
describe(OverallCond)
# Histogram and density plots
p1<-ggplot(data,aes(x=OverallCond))+geom_density()+
labs(title = "Density of OverallCond",x="OverallCond",y="Values")
p2<-ggplot(data,aes(x=OverallCond))+geom_histogram()+
labs(title = "Histogram of OverallCond",x="OverallCond",y="Values")
# This function controls the graphical output device
ggarrange(p1,p2, nrow=1, common.legend = FALSE)
# Missing Values
na_counts <- sum(is.na(data$OverallCond))
print(na_counts)
# Boxplot to visualize outliers
p1 <- ggplot(data, aes(x = OverallCond)) +
geom_boxplot(outlier.colour = "red", outlier.shape = 1, outlier.size = 2) +
coord_flip() +
labs(title = "Boxplot of OverallCond", x = "Values", y = "")
ggarrange(p1, nrow=1, common.legend = FALSE)
# Count outliers
outliers <- boxplot.stats(data$OverallCond)$out
# Display the count of outliers
cat("Number of outliers:", length(outliers), "\n")
# Identify rows with outliers
outlier_rows <- which(data$OverallCond %in% outliers)
# Print the indices of rows with outliers
cat("Indices of rows with outliers:", outlier_rows, "\n")
# Remove rows with outliers
data <- data[-outlier_rows, ]
# Print a message after removing outliers
cat("Outliers removed. New number of rows:", nrow(data), "\n")
# Classical numeric descriptive analysis
describe(YearBuilt)
# Histogram and density plots
p1<-ggplot(data,aes(x=YearBuilt))+geom_density()+
labs(title = "Density of YearBuilt",x="YearBuilt",y="Values")
p2<-ggplot(data,aes(x=YearBuilt))+geom_histogram()+
labs(title = "Histogram of YearBuilt",x="YearBuilt",y="Values")
# This function controls the graphical output device
ggarrange(p1,p2, nrow=1, common.legend = FALSE)
# Missing Values
na_counts <- sum(is.na(data$YearBuilt))
print(na_counts)
print(na_counts/nrow(data))
# Boxplot to visualize outliers
p1 <- ggplot(data, aes(x = YearBuilt)) +
geom_boxplot(outlier.colour = "red", outlier.shape = 1, outlier.size = 2) +
coord_flip() +
labs(title = "Boxplot of YearBuilt", x = "Values", y = "")
ggarrange(p1, nrow=1, common.legend = FALSE)
# Count outliers
outliers <- boxplot.stats(data$YearBuilt)$out
# Display the count of outliers
cat("Number of outliers:", length(outliers), "\n")
# Identify rows with outliers
outlier_rows <- which(data$YearBuilt %in% outliers)
# Print the indices of rows with outliers
cat("Indices of rows with outliers:", outlier_rows, "\n")
# Remove rows with outliers
data <- data[-outlier_rows, ]
# Print a message after removing outliers
cat("Outliers removed. New number of rows:", nrow(data), "\n")
# Basic descriptive statistics
freq(ExterQual)
# Pie chart and bar graph
p1<-ggplot(data, aes(x=factor(1), fill = ExterQual))+geom_bar()+
coord_polar("y")+labs(x="ExterQual",y="%")
p2<-ggplot(data, aes(x=factor(1), fill = ExterQual))+geom_bar()+
labs(x="ExterQual",y="%")
# This function controls the graphical output device
ggarrange(p1,p2,nrow = 1,ncol=2, common.legend = TRUE)
# Basic descriptive statistics
freq(ExterCond)
# Pie chart and bar graph
p1<-ggplot(data, aes(x=factor(1), fill = ExterCond))+geom_bar()+
coord_polar("y")+labs(x="ExterCond",y="%")
p2<-ggplot(data, aes(x=factor(1), fill = ExterCond))+geom_bar()+
labs(x="ExterCond",y="%")
# This function controls the graphical output device
ggarrange(p1,p2,nrow = 1,ncol=2, common.legend = TRUE)
# Basic descriptive statistics
freq(GarageQual)
# Pie chart and bar graph
p1<-ggplot(data, aes(x=factor(1), fill = GarageQual))+geom_bar()+
coord_polar("y")+labs(x="GarageQual",y="%")
p2<-ggplot(data, aes(x=factor(1), fill = GarageQual))+geom_bar()+
labs(x="GarageQual",y="%")
# This function controls the graphical output device
ggarrange(p1,p2,nrow = 1,ncol=2, common.legend = TRUE)
# Create a mapping for the transformation
garage_qual_mapping <- c(TA = 3, Po = 1, Gd = 4, Fa = 2, Ex = 5)
# Transform GarageQual variable
data <- data %>%
mutate(GarageQual_numeric = ifelse(is.na(GarageQual), 0, garage_qual_mapping[as.character(GarageQual)]))
# Drop the GarageQual variable
data <- select(data, -GarageQual)
# Check the transformed data
print(data$GarageQual_numeric)
# Classical numeric descriptive analysis
describe(data$GarageQual_numeric)
# Histogram and density plots
p1<-ggplot(data,aes(x=GarageQual_numeric))+geom_density()+
labs(title = "Density of GarageQual_numeric",x="GarageQual_numeric",y="Values")
p2<-ggplot(data,aes(x=GarageQual_numeric))+geom_histogram()+
labs(title = "Histogram of GarageQual_numeric",x="GarageQual_numeric",y="Values")
# This function controls the graphical output device
ggarrange(p1,p2, nrow=1, common.legend = FALSE)
# Boxplot to visualize outliers
p1 <- ggplot(data, aes(x = GarageQual_numeric)) +
geom_boxplot(outlier.colour = "red", outlier.shape = 1, outlier.size = 2) +
coord_flip() +
labs(title = "Boxplot of GarageQual_numeric", x = "Values", y = "")
ggarrange(p1, nrow=1, common.legend = FALSE)
# Count outliers
outliers <- boxplot.stats(data$GarageQual_numeric)$out
# Display the count of outliers
cat("Number of outliers:", length(outliers), "\n")
# Identify rows with outliers
outlier_rows <- which(data$GarageQual_numeric %in% outliers)
# Print the indices of rows with outliers
cat("Indices of rows with outliers:", outlier_rows, "\n")
# Remove rows with outliers
data <- data[-outlier_rows, ]
# Print a message after removing outliers
cat("Outliers removed. New number of rows:", nrow(data), "\n")
# Classical numeric descriptive analysis
describe(GrLivArea)
# Histogram and density plots
p1<-ggplot(data,aes(x=GrLivArea))+geom_density()+
labs(title = "Density of GrLivArea",x="GrLivArea",y="Values")
p2<-ggplot(data,aes(x=GrLivArea))+geom_histogram()+
labs(title = "Histogram of GrLivArea",x="GrLivArea",y="Values")
# This function controls the graphical output device
ggarrange(p1,p2, nrow=1, common.legend = FALSE)
# Missing Values
na_counts <- sum(is.na(data$GrLivArea))
print(na_counts)
print(na_counts/nrow(data))
# Boxplot to visualize outliers
p1 <- ggplot(data, aes(x = GrLivArea)) +
geom_boxplot(outlier.colour = "red", outlier.shape = 1, outlier.size = 2) +
coord_flip() +
labs(title = "Boxplot of GrLivArea", x = "Values", y = "")
ggarrange(p1, nrow=1, common.legend = FALSE)
# Count outliers
outliers <- boxplot.stats(data$GrLivArea)$out
# Display the count of outliers
cat("Number of outliers:", length(outliers), "\n")
# Identify rows with outliers
outlier_rows <- which(data$GrLivArea %in% outliers)
# Print the indices of rows with outliers
cat("Indices of rows with outliers:", outlier_rows, "\n")
# Remove rows with outliers
data <- data[-outlier_rows, ]
# Print a message after removing outliers
cat("Outliers removed. New number of rows:", nrow(data), "\n")
# Histogram representation of the column GrLivArea
par(mfcol = c(1, 1))
# Define the column name
j0 <- "GrLivArea"
# Set the sequence for the x-axis
x0 <- seq(min(data[, j0], na.rm = TRUE), max(data[, j0], na.rm = TRUE), length.out = 50)
# Create a histogram for the entire column
hist(data[, j0], prob = TRUE, col = grey(0.8), main = paste("Histogram of", j0), xlab = j0)
# Overlay normal distribution curve
lines(x0, dnorm(x0, mean(data[, j0], na.rm = TRUE), sd(data[, j0], na.rm = TRUE)), col = "blue", lwd = 2)
# Representation of normal quantiles for the column GrLivArea
par(mfrow = c(1, 1))
# Define the column name
j0 <- "GrLivArea"
# Set the sequence for the x-axis
x0 <- seq(min(data[, j0], na.rm = TRUE), max(data[, j0], na.rm = TRUE), length.out = 50)
# Create a quantile-quantile plot
qqnorm(data[, j0], main = paste("Q-Q Plot of", j0), pch = 19, col = 2)
qqline(data[, j0])
summary(data$GrLivArea)
data_tidy <- melt(data, value.name = "value")
# Use the aggregate function with the correct FUN argument
result <- aggregate(value ~ variable, data = data_tidy,
FUN = function(x) shapiro.test(x)$p.value)
# Use the aggregate function with the correct FUN argument
result <- aggregate(value ~ variable, data = data_tidy,
FUN = function(x) {orint(x) shapiro.test(x)$p.value})
# Use the aggregate function with the correct FUN argument
result <- aggregate(value ~ variable, data = data_tidy,
FUN = function(x) {print(x) shapiro.test(x)$p.value})
print(x)
data_tidy <- melt(data, value.name = "value")
# Use the aggregate function with the correct FUN argument
result <- aggregate(value ~ variable, data = data_tidy,
FUN = function(x) {
# Check if all values are identical
if (length(unique(x)) == 1) {
print(x)
} else {
return(shapiro.test(x)$p.value)
}
})
# Print the row corresponding to GrLivArea
print(subset(result, variable == "GrLivArea"))
head(data_tidy)
print(result)
data_tidy <- melt(data, value.name = "value")
head(data_tidy)
# Use the aggregate function with the correct FUN argument
result <- aggregate(value ~ variable, data = data_tidy,
FUN = function(x) {
# Check if all values are identical
if (length(unique(x)) == 1) {
print(x)
} else {
return(shapiro.test(x)$p.value)
}
})
# Print the row corresponding to GrLivArea
print(subset(result, variable == "GrLivArea"))
print(result)
